\chapter{Конструкторская часть}

В данном разделе выполняется и формально описывается функциональная декомпозиция разрабатываемого ПО, даются описания используемых структур данных, описываются применяемые алгоритмы.

\section{Описание функциональной декомпозиции и основные структуры данных}

На рисунке \ref{img:task_diagram_a1} представлена диаграмма IDEF0 результата функциональной декомпозиции разрабатываемого программного обеспечения.

\includeimage{task_diagram_a1}{f}{h}{0.9\textwidth}{Диаграмма IDEF0 результата функциональной декомпозиции ПО}

С учетом параметрического уравнения прямой и условия коллинеарности векторов выводится формула \ref{eq:ray} --- уравнение для нахождения вектора с началом в $(0, 0, 0)$ и концом в конце луча, выпущенного из точки $O$ (origin) по направлению от точки $O$ до $F$ --- $\overrightarrow{D}$ (destination) \cite{божко2007компьютерная}, \cite{роджерс}, \cite{боресков}:
\begin{equation}\label{eq:ray}
	\overrightarrow{P} = \overrightarrow{O} + t \cdot \overrightarrow{D}
\end{equation}

Если поверхность, пересечение луча с которой требуется найти, однозначно задана и известна, то коэффициент $t$ находится с помощью формулы~\ref{eq:ray_t}, то есть для полной информации о луче в рассматриваемых далее алгоритмах достаточно двух величин --- $\overrightarrow{O}, \overrightarrow{D}$.

\begin{equation}\label{eq:ray_t}
	t = \frac{\overrightarrow{P} - \overrightarrow{O}}{\overrightarrow{D}}
\end{equation}

В алгоритме обратной трассировки лучей необходимо, чтобы была известна информация о точке пересечения луча с некоторой поверхностью (для обработки вторичных лучей) и ее спектральных характеристиках (для выполнения вычислений по формуле \ref{eq:intense_whitted}).

Вычислительная стоимость определения пересечений произвольного луча с одним выделенным объектом, как указывают авторы \cite{божко2007компьютерная}, \cite{роджерс}, \cite{боресков}, может оказаться высокой, поэтому для избавления от ненужной части поиска производится проверка пересечения луча с ограничивающим телом объекта.
\textit{Ограничивающее тело} --- некоторое простое геометрическое тело (например, параллелепипед, сфера), описанное около одного или нескольких объектов сцены~\cite{боресков}.
Для организации ограничивающих тел используются иерархические структуры, одной из которых является kD-дерево \cite{боресков}.
\textit{kD-деревом} называется бинарное дерево ограничивающих параллелепипедов, вложенных друг в друга~\cite{боресков}.

Таким образом, возникает необходимость наличия следующих структур (совокупностей) данных для упрощения формального описания используемых алгоритмов:

\begin{itemize}
	\item Point --- информация о координатах в декартовой системе координат (значения $x$, $y$, $z$);
	\item Ray --- информация о луче: начало ($origin$), направление ($destination$);
	\item Material --- информация о спектральных характеристиках поверхности: интенсивность фонового излучения ($ambient$), диффузная составляющая интенсивности поверхности ($diffuse$), коэффициент отражения ($reflection$), коэффициент качества полировки ($polish$);
	\item Hitinfo --- информация о пересечении луча с поверхностью: значение параметра в соответствии с формулой \ref{eq:ray_t} ($t$), информация о материале поверхности ($material$), точка пересечения ($hitPoint$);
	\item BoundingBox --- информация об ограничивающем параллелепипеде: минимальные и максимальные координаты тела ($min\_p$, $max\_p$ соответственно);
	\item Object --- информация об объекте сцены: данные поверхности ($data$), центр ($center$), ограничивающий параллелепипед ($bbox$);
	\item kDNode --- информация об узле kD-дерева: дочерние узлы ($left$, $right$), признак листа ($isLeaf$), ограничивающий параллелепипед ($bbox$), соответствующая направлению декомпозиции ограничивающего параллелепипеда ось ($axis$), массив объектов ($objects$), количество объектов ($size$).
\end{itemize}

Камера (Camera) --- структура данных, содержащая информацию о наблюдателе: местоположение, направления взгляда и вертикальной оси.
Дополнительной информацией являются отношение сторон используемого экрана и область видимости (угол fov), необходимые для обеспечения возможности применения алгоритма обратной трассировки лучей.
Местоположение экрана зависит от камеры.

Используемая модель камеры представлена на рисунке \ref{img:camera}.

\includeimage{camera}{f}{h}{0.9\textwidth}{Используемая модель камеры}

Для выполнения трассировки лучей необходимо иметь возможность вычислить луч, выпущенный из камеры, расположенной в точке $center$, через некоторый пиксель экрана $(i, j)$.

Пусть:
\begin{enumerate}
	\item центр экрана --- точка $display\_center$, его ширина и высота --- $width$ и $height$, а их отношение --- $k = \frac{width}{height}$;
	\item камера расположена в точке $center$, направление взгляда --- $\overrightarrow{view}$, вертикальная ось --- $\overrightarrow{up}$, область видимости задана углом $fov$;
	\item расстояние между камерой и экраном --- $d$.
\end{enumerate}

Тогда из определения тангенса угла выводится формула \ref{eq:display_height}:
\begin{equation}\label{eq:display_height}
	height = 2 \cdot d \cdot tg(fov),
\end{equation}
где $d$ принимается равным 1.

Согласно определению $k$ получается формула \ref{eq:display_width}:
\begin{equation}\label{eq:display_width}
	width = k \cdot height.
\end{equation}

Для вычисления горизонтального и вертикального направлений используются формулы \ref{eq:horizontal}, \ref{eq:vertical} соответственно (после применения каждой из формул результат необходимо нормализовать).

\begin{equation}\label{eq:horizontal}
	\overrightarrow{horizontal} = \overrightarrow{view} \times \overrightarrow{up}
\end{equation}

\begin{equation}\label{eq:vertical}
	\overrightarrow{vertical} = \overrightarrow{horizontal} \times \overrightarrow{view}
\end{equation}

Искомый луч высчитывается относительно начала отсчета, в качестве которого выбрана нижняя левая точка экрана --- $lower\_left$ (то есть вектор $\overrightarrow{lower\_left}$).
Для нахождения начала отсчета используется формула \ref{eq:lower_left}:

\begin{equation}\label{eq:lower_left}
	\overrightarrow{lower\_left} = \overrightarrow{view} - \frac{\overrightarrow{display\_h} + \overrightarrow{display\_v}}{2},
\end{equation}
где $\overrightarrow{display\_h} = width \cdot \overrightarrow{horizontal}$, $\overrightarrow{display\_v} = height \cdot \overrightarrow{vertical}$.

С использованием формулы \ref{eq:lower_left} получаем конечную формулу \ref{eq:ray_ij} для вычисления луча:
\begin{equation}\label{eq:ray_ij}
	\overrightarrow{ray} = \overrightarrow{lower\_left} + i \cdot \overrightarrow{display\_h} + j \cdot \overrightarrow{display\_v}
\end{equation}

Доступ к данным структур будет условно обозначаться с использованием оператора <<.>>.

\section{Схемы используемых алгоритмов}

Схема алгоритма построения kD-дерева представлена на рисунке \ref{img:algorithm_kd_tree_build}.

% kd_tree_build

Схема алгоритма поиска пересечения луча с kD-деревом представлена на рисунке \ref{img:algorithm_kd_tree_intersect}.

% kd_tree_intersect

Схема алгоритма добавления объекта в kD-дерево представлена на рисунке \ref{img:algorithm_kd_tree_add}.

% kd_tree_add

На рисунке \ref{img:algorithm_raytracing} приведены схемы алгоритмов обработки одного луча и перебора всех лучей, выпускаемых из камеры.

% raytracing

\section{Перенос и поворот}

Также согласно техническому заданию необходимо изменять положение источника света, то есть дать пользователю возможность выполнить перенос в отношении источника света, который реализовывается с помощью матрицы переноса в трехмерном пространстве, представленной в формуле \ref{eq:matrix_move} \cite{куров}, \cite{боресков}.

Аналогично перенос камеры осуществляется с помощью матрицы, представленной в формуле \ref{eq:matrix_move}, а поворот в отношении камеры реализовывается c использованием матриц поворота вокруг осей $x$, $y$, $z$ на угол $\alpha$, которые представлены в формулах \ref{eq:matrix_rotate_x}, \ref{eq:matrix_rotate_y}, \ref{eq:matrix_rotate_z} соответственно \cite{куров}, \cite{боресков}.

\begin{equation}\label{eq:matrix_move}
	M(dx, dy, dz) = \begin{pmatrix}
		1 & 0 & 0 & 0 \\
		0 & 1 & 0 & 0 \\
		0 & 0 & 1 & 0 \\
		dx & dy & dz & 1
	\end{pmatrix}
\end{equation}

\begin{equation}\label{eq:matrix_rotate_x}
	R_x(\alpha) = \begin{pmatrix}
		1 & 0 & 0 \\
		0 & cos(\alpha) & -sin(\alpha) \\
		0 & sin(\alpha) & cos(\alpha)
	\end{pmatrix}
\end{equation}

\begin{equation}\label{eq:matrix_rotate_y}
	R_y(\alpha) = \begin{pmatrix}
		cos(\alpha) & 0 & sin(\alpha) \\
		0 & 1 & 0 \\
		-sin(\alpha) & 0 & cos(\alpha)
	\end{pmatrix}
\end{equation}

\begin{equation}\label{eq:matrix_rotate_z}
	R_z(\alpha) = \begin{pmatrix}
		cos(\alpha) & -sin(\alpha) & 0 \\
		sin(\alpha) & cos(\alpha) & 0 \\
		0 & 0 & 1
	\end{pmatrix}
\end{equation}

\section*{Вывод}

В данном разделе были формально описаны функциональная декомпозиция разрабатываемого ПО и применяемые алгоритмы, даны описания используемых структур данных.