\chapter{Конструкторская часть}

В данном разделе выполняется и формально описывается функциональная декомпозиция разрабатываемого ПО, даются описания применяемых алгоритмов и формата входных данных.

% добавить формат входных данных
\section{Формат хранения данных}

В качестве хранения информации об объектах сцены используется формат данных STL, в котором поверхности модели объекта и их нормали описываются списком треугольных граней.
Заранее созданные сторонними пакетами базовые модели объектов, хранящиеся в формате STL, могут быть загружены в программу, обработаны и модифицированы пользователем.
Пример разбития поверхности на треугольные грани приведен на рисунке \ref{img:stl_example}.

\includeimage{stl_example}{f}{h}{0.9\textwidth}{Разбитие поверхности на треугольные грани}

% алгоритм поиска пересечения с треугольной гранью?

\section{Описание функциональной декомпозиции}

На рисунке \ref{img:task_diagram_a1} представлена диаграмма IDEF0 результата функциональной декомпозиции разрабатываемого программного обеспечения.

\includeimage{task_diagram_a1}{f}{h}{0.9\textwidth}{Диаграмма IDEF0 результата функциональной декомпозиции ПО}

% нужна подводка к тому что ниже
% "сказать, что для реализации такой штуки, так как используется алгоритм обратной трассировки лучшей, используется следующий способ задания луча"

Так как в работе применяется алгоритм обратной трассировки лучей, необходимо иметь возможность задавать луч.

С учетом параметрического уравнения прямой и условия коллинеарности векторов выводится формула \ref{eq:ray} --- уравнение для нахождения вектора с началом в $(0, 0, 0)$ и концом в конце луча, выпущенного из точки $O$ (origin) по направлению от точки $O$ до $F$ --- $\overrightarrow{D}$ (destination) \cite{божко2007компьютерная}, \cite{роджерс}, \cite{боресков}:
\begin{equation}\label{eq:ray}
	\overrightarrow{P} = \overrightarrow{O} + t \cdot \overrightarrow{D}
\end{equation}

Если поверхность, пересечение луча с которой требуется найти, однозначно задана и известна, то коэффициент $t$ находится с помощью формулы~\ref{eq:ray_t}, то есть для полной информации о луче в рассматриваемых далее алгоритмах достаточно задать значения двух величин --- $\overrightarrow{O}, \overrightarrow{D}$.

\begin{equation}\label{eq:ray_t}
	t = \frac{\overrightarrow{P} - \overrightarrow{O}}{\overrightarrow{D}}
\end{equation}

Вычислительная стоимость определения пересечений произвольного луча с одним выделенным объектом, как указывают авторы \cite{божко2007компьютерная}, \cite{роджерс}, \cite{боресков}, может оказаться высокой, поэтому для избавления от ненужной части поиска производится проверка пересечения луча с ограничивающим телом объекта.
\textit{Ограничивающее тело} --- некоторое простое геометрическое тело (например, параллелепипед, сфера), описанное около одного или нескольких объектов сцены~\cite{боресков}.
Для организации ограничивающих тел используются иерархические структуры, одной из которых является kD-дерево \cite{боресков}.
\textit{kD-деревом} называется бинарное дерево ограничивающих параллелепипедов, вложенных друг в друга~\cite{боресков}.

В соответствии с алгоритмом обратной трассировки лучей все лучи испускаются из камеры, поэтому ее необходимо формализовать.
Камера представлена моделью, которая приведена на рисунке \ref{img:camera}.

\includeimage{camera}{f}{h}{0.9\textwidth}{Используемая модель камеры}

Для выполнения трассировки лучей необходимо иметь возможность вычислить луч, выпущенный из камеры, расположенной в точке $center$, через некоторый пиксель экрана $(i, j)$.

Пусть:
\begin{enumerate}
	\item центр экрана --- точка $display\_center$, его ширина и высота --- $width$ и $height$, а их отношение --- $k = \frac{width}{height}$;
	\item камера расположена в точке $center$, направление взгляда --- $\overrightarrow{view}$, вертикальная ось --- $\overrightarrow{up}$, область видимости задана углом $fov$;
	\item расстояние между камерой и экраном --- $d$.
\end{enumerate}

Тогда из определения тангенса угла выводится формула \ref{eq:display_height}:
\begin{equation}\label{eq:display_height}
	height = 2 \cdot d \cdot tg(fov),
\end{equation}
где $d$ принимается равным 1.

Согласно определению $k$ получается формула \ref{eq:display_width}:
\begin{equation}\label{eq:display_width}
	width = k \cdot height.
\end{equation}

Для вычисления горизонтального и вертикального направлений используются формулы \ref{eq:horizontal}, \ref{eq:vertical} соответственно (после применения каждой из формул результат необходимо нормализовать).

\begin{equation}\label{eq:horizontal}
	\overrightarrow{horizontal} = \overrightarrow{view} \times \overrightarrow{up}
\end{equation}

\begin{equation}\label{eq:vertical}
	\overrightarrow{vertical} = \overrightarrow{horizontal} \times \overrightarrow{view}
\end{equation}

Искомый луч высчитывается относительно начала отсчета, в качестве которого выбрана нижняя левая точка экрана --- $lower\_left$ (то есть вектор $\overrightarrow{lower\_left}$).
Для нахождения начала отсчета используется формула \ref{eq:lower_left}:

\begin{equation}\label{eq:lower_left}
	\overrightarrow{lower\_left} = \overrightarrow{view} - \frac{\overrightarrow{display\_h} + \overrightarrow{display\_v}}{2},
\end{equation}
где $\overrightarrow{display\_h} = width \cdot \overrightarrow{horizontal}$, $\overrightarrow{display\_v} = height \cdot \overrightarrow{vertical}$.

С использованием формулы \ref{eq:lower_left} получаем конечную формулу \ref{eq:ray_ij} для вычисления луча:
\begin{equation}\label{eq:ray_ij}
	\overrightarrow{ray} = \overrightarrow{lower\_left} + i \cdot \overrightarrow{display\_h} + j \cdot \overrightarrow{display\_v}
\end{equation}

\section{Схемы используемых алгоритмов}

Схема алгоритма построения kD-дерева представлена на рисунке \ref{img:algorithm_kd_tree_build}.

% kd_tree_build

Схема алгоритма поиска пересечения луча с kD-деревом представлена на рисунке \ref{img:algorithm_kd_tree_intersect}.

% kd_tree_intersect

Схема алгоритма добавления объекта в kD-дерево представлена на рисунке \ref{img:algorithm_kd_tree_add}.

% kd_tree_add

На рисунке \ref{img:algorithm_raytracing} приведены схемы алгоритмов обработки одного луча и перебора всех лучей, выпускаемых из камеры.

% raytracing

\section{Перенос и поворот}

Также согласно техническому заданию необходимо изменять положение источника света, то есть дать пользователю возможность выполнить перенос в отношении источника света, который реализовывается с помощью матрицы переноса в трехмерном пространстве, представленной в формуле \ref{eq:matrix_move} \cite{куров}, \cite{боресков}.

Аналогично перенос камеры осуществляется с помощью матрицы, представленной в формуле \ref{eq:matrix_move}, а поворот в отношении камеры реализовывается c использованием матриц поворота вокруг осей $x$, $y$, $z$ на угол $\alpha$, которые представлены в формулах \ref{eq:matrix_rotate_x}, \ref{eq:matrix_rotate_y}, \ref{eq:matrix_rotate_z} соответственно \cite{куров}, \cite{боресков}.

\begin{equation}\label{eq:matrix_move}
	M(dx, dy, dz) = \begin{pmatrix}
		1 & 0 & 0 & 0 \\
		0 & 1 & 0 & 0 \\
		0 & 0 & 1 & 0 \\
		dx & dy & dz & 1
	\end{pmatrix}
\end{equation}

\begin{equation}\label{eq:matrix_rotate_x}
	R_x(\alpha) = \begin{pmatrix}
		1 & 0 & 0 \\
		0 & cos(\alpha) & -sin(\alpha) \\
		0 & sin(\alpha) & cos(\alpha)
	\end{pmatrix}
\end{equation}

\begin{equation}\label{eq:matrix_rotate_y}
	R_y(\alpha) = \begin{pmatrix}
		cos(\alpha) & 0 & sin(\alpha) \\
		0 & 1 & 0 \\
		-sin(\alpha) & 0 & cos(\alpha)
	\end{pmatrix}
\end{equation}

\begin{equation}\label{eq:matrix_rotate_z}
	R_z(\alpha) = \begin{pmatrix}
		cos(\alpha) & -sin(\alpha) & 0 \\
		sin(\alpha) & cos(\alpha) & 0 \\
		0 & 0 & 1
	\end{pmatrix}
\end{equation}

\section*{Вывод}

В данном разделе были формально описаны функциональная декомпозиция разрабатываемого ПО и применяемые алгоритмы, даны описания используемых структур данных.