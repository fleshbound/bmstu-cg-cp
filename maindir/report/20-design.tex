\chapter{Конструкторская часть}

В данном разделе описывается формат хранения данных, алгоритм обратной трассировки лучей и изменение местоположения объектов сцены, выполняется функциональная декомпозиция.

\section{Хранение данных, обратная трассировка лучей}

В качестве хранения информации об объектах сцены используется формат данных STL, в котором поверхности модели объекта и их нормали описываются списком треугольных граней \cite{szilvsi2003analysis}.
Заранее созданные сторонними пакетами базовые модели объектов, хранящиеся в формате STL, загружаются в программу, обрабатываются и изменяются пользователем.
Пример разбития поверхности на треугольные грани приведен на рисунке \ref{img:stl_example}.

\includeimage{stl_example}{f}{h}{0.9\textwidth}{Разбитие поверхности на треугольные грани \cite{szilvsi2003analysis}}

В работе применяется алгоритм обратной трассировки лучей, суть которого заключается в выпускании из камеры через каждый пиксель экрана множества лучей и отдельной обработке каждого луча.

\subsection{Формальное описание луча}

Пример изображения луча, выпущенного из точки $O$ (origin) по направлению от точки $O$ до $F$ --- $\overrightarrow{D}$ (destination), приведен на рисунке \ref{img:ray}.
С учетом параметрического уравнения прямой и условия коллинеарности векторов выводится уравнение для вычисления конца этого луча, представленное в формуле \ref{eq:ray} \cite{божко2007компьютерная}, \cite{роджерс}, \cite{боресков}:
\begin{equation}\label{eq:ray}
	P = O + t \cdot \overrightarrow{D}
\end{equation}

\includeimage{ray}{f}{h}{0.9\textwidth}{Изображение луча, выпущенного из точки $O$ (origin) по направлению от точки $O$ до $F$}

Если поверхность, пересечение луча с которой требуется найти, однозначно задана и известна, то коэффициент $t$ находится с помощью формулы~\ref{eq:ray_t}, то есть для полной информации о луче в рассматриваемых далее алгоритмах достаточно задать значения двух величин --- $\overrightarrow{O}, \overrightarrow{D}$.

\begin{equation}\label{eq:ray_t}
	t = \frac{\overrightarrow{P} - \overrightarrow{O}}{\overrightarrow{D}}
\end{equation}

Все лучи испускаются из камеры, поэтому ее необходимо формализовать.
Камера представлена моделью, которая приведена на рисунке \ref{img:camera}.

\includeimage{camera}{f}{h}{0.9\textwidth}{Используемая модель камеры}

Для выполнения обратной трассировки лучей необходимо иметь возможность вычислить луч, выпущенный из камеры, расположенной в точке $center$, через некоторый пиксель экрана $(i, j)$.

Пусть:
\begin{enumerate}
	\item центр экрана --- точка $display\_center$, его ширина и высота --- $width$ и $height$, а их отношение --- $k = \frac{width}{height}$;
	\item камера расположена в точке $center$, направление взгляда --- $\overrightarrow{view}$, вертикальная ось --- $\overrightarrow{up}$, область видимости задана углом $fov$;
	\item $d$ --- расстояние между камерой и экраном.
\end{enumerate}

Тогда из определения тангенса угла выводится формула \ref{eq:display_height}:
\begin{equation}\label{eq:display_height}
	height = 2 \cdot d \cdot tg(fov),
\end{equation}
где $d$ принимается равным 1.

Согласно определению $k$ получается формула \ref{eq:display_width}:
\begin{equation}\label{eq:display_width}
	width = k \cdot height.
\end{equation}

Для вычисления горизонтального и вертикального направлений используются формулы \ref{eq:horizontal}, \ref{eq:vertical} соответственно (после применения каждой из формул результат необходимо нормализовать).

\begin{equation}\label{eq:horizontal}
	\overrightarrow{horizontal} = \overrightarrow{view} \times \overrightarrow{up}
\end{equation}

\begin{equation}\label{eq:vertical}
	\overrightarrow{vertical} = \overrightarrow{horizontal} \times \overrightarrow{view}
\end{equation}

Искомый луч высчитывается относительно начала отсчета, в качестве которого выбрана нижняя левая точка экрана --- $lower\_left$ (то есть вектор $\overrightarrow{lower\_left}$).
Для нахождения начала отсчета используется формула \ref{eq:lower_left}:

\begin{equation}\label{eq:lower_left}
	\overrightarrow{lower\_left} = \overrightarrow{view} - \frac{\overrightarrow{display\_h} + \overrightarrow{display\_v}}{2},
\end{equation}
где $\overrightarrow{display\_h} = width \cdot \overrightarrow{horizontal}$, $\overrightarrow{display\_v} = height \cdot \overrightarrow{vertical}$.

С использованием формулы \ref{eq:lower_left} получаем конечную формулу \ref{eq:ray_ij} для вычисления луча, выпущенного из камеры через некоторый пиксель $(i, j)$ экрана:
\begin{equation}\label{eq:ray_ij}
	\overrightarrow{ray} = \overrightarrow{lower\_left} + i \cdot \overrightarrow{display\_h} + j \cdot \overrightarrow{display\_v}
\end{equation}

\subsection{Обработка пересечения луча с объектом}

Обработка луча в рамках рассматриваемого алгоритма заключается в поиске пересечения луча с объектом сцены, то есть с некоторой треугольной гранью, которая принадлежит объекту.
Вычислительная стоимость определения пересечений произвольного луча с одним выделенным объектом, как указывают авторы \cite{божко2007компьютерная}, \cite{роджерс}, \cite{боресков}, может оказаться высокой, поэтому для избавления от ненужной части поиска производится проверка пересечения луча с ограничивающим телом объекта.

\textit{Ограничивающее тело} --- некоторое простое геометрическое тело (например, параллелепипед, сфера), описанное около одного или нескольких объектов сцены~\cite{боресков}.
Для организации ограничивающих тел используются иерархические структуры, одной из которых является kD-дерево \cite{боресков}.

\textit{kD-деревом} называется бинарное дерево ограничивающих параллелепипедов, вложенных друг в друга~\cite{боресков}.

Таким образом, для поиска пересечения отдельного луча с некоторым объектом необходимо иметь возможность вычислить пересечение (или определить его наличие) с kD-деревом, ограничивающим параллелепипедом и треугольной гранью этого объекта.

Схема алгоритма поиска пересечения луча с треугольной гранью объекта (в соответствии с описанием из \cite{moller2005fast}) представлена на рисунке \ref{img:algorithm_tri_intersect}.

На рисунке \ref{img:algorithm_bbox_intersect} приведена схема алгоритма определения наличия пересечения луча с ограничивающим параллелепипедом.

Схема алгоритма поиска пересечения луча с узлом kD-дерева представлена на рисунке \ref{img:algorithm_kdtree_intersect}.
\clearpage

\includeimage{algorithm_tri_intersect}{f}{h!}{0.9\textwidth}{Схема алгоритма поиска пересечения луча с треугольной гранью}

\includeimage{algorithm_bbox_intersect}{f}{h!}{0.9\textwidth}{Схема алгоритма определения наличия пересечения луча с ограничивающим параллелепипедом}

\includeimage{algorithm_kdtree_intersect}{f}{h!}{0.9\textwidth}{Схема алгоритма определения пересечения луча с узлом kD-дерева}

\subsection{Схема алгоритма обратной трассировки лучей}

Схемы алгоритмов обработки отдельного луча и обратной трассировки лучей (с использованиемч формулы \ref{eq:ray_ij}) представлены на рисунках \ref{img:algorithm_trace} и \ref{img:algorithm_raytracing} соответственно.

\includeimage{algorithm_trace}{f}{h!}{0.9\textwidth}{Схемы алгоритмов обработки отдельного луча и обратной трассировки лучей}

\clearpage

\includeimage{algorithm_raytracing}{f}{h!}{0.9\textwidth}{Схемы алгоритмов обработки отдельного луча и обратной трассировки лучей}

\section{Функциональная декомпозиция}

Диаграмма IDEF0 функциональной декомпозиции проектируемого ПО представлена на рисунке \ref{img:task_diagram_a1}.

\includeimage{task_diagram_a1}{f}{h!}{0.9\textwidth}{Диаграмма IDEF0 функциональной декомпозиции проектируемого ПО}

\section{Перенос и поворот объектов сцены}

Согласно техническому заданию необходимо изменять положение источника света, то есть дать пользователю возможность выполнить перенос в отношении источника света, который реализовывается с помощью матрицы переноса в трехмерном пространстве, представленной в формуле \ref{eq:matrix_move} \cite{куров}, \cite{боресков}.

Аналогично перенос камеры осуществляется с помощью матрицы, представленной в формуле \ref{eq:matrix_move}, а поворот в отношении камеры реализовывается c использованием матриц поворота вокруг осей $x$, $y$, $z$ на угол $\alpha$, которые представлены в формулах \ref{eq:matrix_rotate_x}, \ref{eq:matrix_rotate_y}, \ref{eq:matrix_rotate_z} соответственно \cite{куров}, \cite{боресков}.

\begin{equation}\label{eq:matrix_move}
	M(dx, dy, dz) = \begin{pmatrix}
		1 & 0 & 0 & 0 \\
		0 & 1 & 0 & 0 \\
		0 & 0 & 1 & 0 \\
		dx & dy & dz & 1
	\end{pmatrix}
\end{equation}

\begin{equation}\label{eq:matrix_rotate_x}
	R_x(\alpha) = \begin{pmatrix}
		1 & 0 & 0 \\
		0 & cos(\alpha) & -sin(\alpha) \\
		0 & sin(\alpha) & cos(\alpha)
	\end{pmatrix}
\end{equation}

\begin{equation}\label{eq:matrix_rotate_y}
	R_y(\alpha) = \begin{pmatrix}
		cos(\alpha) & 0 & sin(\alpha) \\
		0 & 1 & 0 \\
		-sin(\alpha) & 0 & cos(\alpha)
	\end{pmatrix}
\end{equation}

\begin{equation}\label{eq:matrix_rotate_z}
	R_z(\alpha) = \begin{pmatrix}
		cos(\alpha) & -sin(\alpha) & 0 \\
		sin(\alpha) & cos(\alpha) & 0 \\
		0 & 0 & 1
	\end{pmatrix}
\end{equation}

\section*{Вывод}

В данном разделе были описаны алгоритм обратной трассировки лучей, формат хранения данных и средства для осуществления переноса и поворота объектов сцены, выполнена функциональная декомпозиция.